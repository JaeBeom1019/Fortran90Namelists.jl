"""
# module Tokenize



# Examples

```jldoctest
julia>
```
"""
module Tokenize

using DataStructures: Deque
using IterTools: takewhile
using Parameters: @with_kw

export Tokenizer,
    update_chars,
    parse_name,
    parse_string,
    parse_numeric

const PUNCTUATION = raw"=+-*/\\()[]{},:;%&~<>?`|$#@"

@with_kw mutable struct Tokenizer
    characters = nothing
    prior_char = nothing
    char = nothing
    idx = nothing
    whitespace = " \t\r\x0b\x0c"
    prior_delim = nothing
    group_token = nothing  # Set to true if inside a namelist group
end  # struct Tokenizer

"""
    update_chars(tk::Tokenizer)

Update the current charters in the tokenizer.
"""
function update_chars(tk::Tokenizer)
    tk.prior_char, tk.char = tk.char, next(tk.characters, '\n')
    tk.idx += 1
end  # function update_chars

function Base.parse(tk::Tokenizer, line)
    tokens = []
    tk.idx = 0   # Bogus value to ensure idx = 1 after first iteration
    tk.characters = line  # Is an iterator generated by line
    update_chars(tk)

    while tk.char != "\n"
        # Update namelist group status
        tk.char in ('&', '$') && tk.group_token = tk.char

        if tk.group_token && ((tk.group_token, tk.char) in (('&', '/'), ('$', '$')))
            tk.group_token = nothing  # A group (namelist) ends
        end

        word = ""
        # Ignore whitespace
        if occursin(tk.char, tk.whitespace)  # " \t\r\x0b\x0c"
            while occursin(tk.char, tk.whitespace)
                word *= tk.char  # Read one char to `word`
                update_chars(tk)  # Read the next char until meet a non-whitespace char
            end
        # Ignore comment
        elseif occursin(tk.char, "!#") || isnothing(tk.group_token)  # Comment line
            word = line[tk.idx:end]  # Read `word` until end
            tk.char = "\n"
        # Parse string
        elseif occursin(tk.char, "\"'") || !isnothing(tk.prior_delim)  # Meet a string
            word = parse_string(tk)
        # Parse variable
        elseif isletter(tk.char)  # Meet a variable
            word = parse_name(tk, line)
        # Meet a sign
        elseif tk.char in ('+', '-')
            # Lookahead to check for IEEE value
            tk.characters, lookahead = tee(tk.characters)  # FIXME:
            ieee_val = join(takewhile(isletter, lookahead), "")
            if lowercase(ieee_val) in ("inf", "infinity", "nan")  # Meet an nan/infinity
                word = tk.char * ieee_val
                tk.characters = lookahead
                tk.prior_char = ieee_val[end]
                tk.char = next(lookahead, '\n')
            else
                word = parse_numeric(tk)  # Meet a number
            end
        # Meet a number
        elseif isdigit(tk.char)
            word = parse_numeric(tk)
        # Meet a dot
        elseif tk.char == '.'
            update_chars(tk)
            if isdigit(tk.char)
                frac = parse_numeric(tk)  # A fraction of a number
                word = '.' * frac
            else
                word = '.'  # If not followed by a number
                while isletter(tk.char)
                    word *= tk.char
                    update_chars(tk)
                end
                # A word containing `.` ends
                if tk.char == '.'
                    word *= tk.char
                    update_chars(tk)
                end
            end
        # Meet a punctuation
        elseif occursin(tk.char, PUNCTUATION)
            word = tk.char
            update_chars(tk)
        else
            # This should never happen
            error("")
        end
        push!(tokens, word)
    end  # while loop
    return tokens
end  # function Base.parse

function parse_name(tk::Tokenizer, line)
    endindex = tk.idx
    for char in line[tk.idx:end]
        !isalnum(char) && !occursin(char, "\'\"_") && break
        endindex += 1
    end

    word = line[tk.idx:end]

    tk.idx = endindex - 1
    # Update iterator, minus first character which was already read
    tk.characters = itertools.islice(tk.characters, length(word) - 1, nothing)
    update_chars(tk)
    return word
end  # function parse_name

"""
    parse_string(tk::Tokenizer)

Tokenize a Fortran string.
"""
function parse_string(tk::Tokenizer)
    word = ""

    if isnothing(tk.prior_delim)  # FIXME:
        delim = tk.prior_delim
        tk.prior_delim = nothing
    else
        delim = tk.char
        word *= tk.char
        update_chars(tk)
    end

    while true
        if tk.char == delim
            # Check for escaped delimiters
            update_chars(tk)
            if tk.char == delim
                word *= repeat(delim, 2)
                update_chars(tk)
            else
                word *= delim && break
            end
        elseif tk.char == '\n'
            tk.prior_delim = delim && break
        else
            word *= tk.char
            update_chars(tk)
        end
    end

    return word
end  # function parse_string

"""
    parse_numeric(tk::Tokenizer)

Tokenize a Fortran numerical value.
"""
function parse_numeric(tk::Tokenizer)
    word = ""
    frac = false

    if tk.char == '-'
        word *= tk.char
        update_chars(tk)
    end

    while isdigit(tk.char) || (tk.char == '.' && !frac)
        # Only allow one decimal point
        if tk.char == '.'
            frac = true
        end
        word *= tk.char
        update_chars(tk)
    end

    # Check for float exponent
    if occursin(tk.char, "eEdD")
        word *= tk.char
        update_chars(tk)
    end

    if occursin(tk.char, "+-")
        word *= tk.char
        update_chars(tk)
    end

    while isdigit(tk.char)
        word *= tk.char
        update_chars(tk)
    end

    return word
end  # function parse_numeric

isalnum(c) = isletter(c) || isnumeric(c)

function tee(iterable, n::Int =2)
    deques = [Deque() for i in range(n)]
    function gen(mydeque)
        while true
            if !isempty(mydeque)             # when the local deque is empty
                try:
                    newval, state = iterate(iterable)   # fetch a new value and
                    return
                for d in deques        # load it to all the deques
                    push!(d, newval)
                end
            end
            yield popfirst!(mydeque)
            end
        end
    end  # function gen
    return tuple(gen(d) for d in deques)
end  # function tee

function next(iterable, default)
    x = iterate(iterable)
    isnothing(x) ? default : first(x)
end

end
